<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>volatile的作用</title>
    <link href="/2020/volatile-de-zuo-yong/"/>
    <url>/2020/volatile-de-zuo-yong/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile使线程间可见"><a href="#volatile使线程间可见" class="headerlink" title="volatile使线程间可见"></a>volatile使线程间可见</h1><h2 id="CPU与内存的关系"><a href="#CPU与内存的关系" class="headerlink" title="CPU与内存的关系"></a>CPU与内存的关系</h2><p><img src="https://s1.ax1x.com/2020/04/29/JIz1Ig.png" srcset="/img/loading.gif" alt="1588061371425"></p><h2 id="volatile线程间可见"><a href="#volatile线程间可见" class="headerlink" title="volatile线程间可见"></a>volatile线程间可见</h2><p><img src="https://s1.ax1x.com/2020/04/29/JIzHSA.png" srcset="/img/loading.gif" alt="1588061474330"></p><p>主方法改变变量不能停掉线程t1，因为线程读自己的缓存，<strong>volatile修饰符通知其他线程重新读</strong>。</p><h2 id="CPU内部缓存"><a href="#CPU内部缓存" class="headerlink" title="CPU内部缓存"></a>CPU内部缓存</h2><p><img src="https://s1.ax1x.com/2020/04/29/JoStte.png" srcset="/img/loading.gif" alt="1588061920941"></p><p>缓存行一次读64个字节，越大局部性空间效率高，但时间慢，越小局部性空间效率低，速度快，所以取折中值。</p><p><img src="https://s1.ax1x.com/2020/04/29/JoSNfH.png" srcset="/img/loading.gif" alt="1588062142437"></p><p>缓存行的四种状态</p><p><img src="https://s1.ax1x.com/2020/04/29/JoSapd.png" srcset="/img/loading.gif" alt="1588062448234"><br>long数组在同一个缓存行中修改两个值，会造成额外的消耗。</p><p><img src="https://s1.ax1x.com/2020/04/29/JoSDnP.png" srcset="/img/loading.gif" alt="1588062538057"></p><p>优化数组长度。</p><p><img src="https://s1.ax1x.com/2020/04/29/JoS6AS.png" srcset="/img/loading.gif" alt="1588062619347"></p><p>单机最快的队列disruptor</p><h1 id="volatile可以禁止指令重排序"><a href="#volatile可以禁止指令重排序" class="headerlink" title="volatile可以禁止指令重排序"></a>volatile可以禁止指令重排序</h1><h2 id="CPU是乱序执行的"><a href="#CPU是乱序执行的" class="headerlink" title="CPU是乱序执行的"></a>CPU是乱序执行的</h2><p><img src="https://s1.ax1x.com/2020/04/29/JoSghQ.png" srcset="/img/loading.gif" alt="1588060637041"></p><p>CPU的速度比内存快，极小概率会出现乱序情况</p><h2 id="证明乱序"><a href="#证明乱序" class="headerlink" title="证明乱序"></a>证明乱序</h2><p><img src="https://s1.ax1x.com/2020/04/29/JoSW1s.png" srcset="/img/loading.gif" alt="1588060707442"></p><p>两个线程的步骤无论怎么组合不可能出现x=0，y=0的情况，说明xy的执行在前面，<strong>CPU内部可以对指令重排序。</strong></p><p><img src="https://s1.ax1x.com/2020/04/29/JoSfcn.png" srcset="/img/loading.gif" alt="1588060897275"></p><h2 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h2><p><img src="https://s1.ax1x.com/2020/04/29/JoS7AU.png" srcset="/img/loading.gif" alt="1588059382004"></p><p>0&gt; new先申请</p><p>1&gt; m=0是半初始化状态</p><p>4&gt; 调用构造方法把m=8，是全初始化状态</p><p>7&gt; 连接t和m</p><h2 id="DCL-double-check-lock-单例双重检查锁"><a href="#DCL-double-check-lock-单例双重检查锁" class="headerlink" title="DCL(double check lock)单例双重检查锁"></a>DCL(double check lock)单例双重检查锁</h2><p><img src="https://s1.ax1x.com/2020/04/29/JoSbh4.png" srcset="/img/loading.gif" alt="1588060224254"></p><p>避免其他线程创建Mgr06</p><p><img src="https://s1.ax1x.com/2020/04/29/JoSO39.png" srcset="/img/loading.gif" alt="1588060547599"></p><p>DCL单例必须加volatile，<strong>volatile可以禁止指令重排序。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA打jar包</title>
    <link href="/2020/idea-da-jar-bao/"/>
    <url>/2020/idea-da-jar-bao/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA打jar包步骤"><a href="#IDEA打jar包步骤" class="headerlink" title="IDEA打jar包步骤"></a>IDEA打jar包步骤</h1><blockquote><p>IntelliJ IDEA 2019.3 (Ultimate Edition)</p><p>java8</p></blockquote><ol><li>选中Java项目工程名称，在菜单中选择 File-&gt;project structure.</li></ol><p><img src="https://s1.ax1x.com/2020/03/26/GplVaj.png" srcset="/img/loading.gif" alt="GplVaj.png"></p><ol start="2"><li><p>在弹出的窗口中左侧选中”Artifacts”，点击”+”选择jar，然后选择”from modules with dependencies”。</p><p><img src="https://s1.ax1x.com/2020/03/26/Gplhy8.png" srcset="/img/loading.gif" alt="Gplhy8.png"></p></li><li><p>配置main class,删除路径后的<code>\main\java</code>并保存.(如果不修改，打成的jar包里没有包含META-INF/MAINFEST.MF文件)</p><p><img src="https://s1.ax1x.com/2020/03/26/GplXlV.png" srcset="/img/loading.gif" alt="GplXlV.png"></p></li><li><p>回到IDEA的主菜单，选择“Build - Build Artifacts”下的“Build”或者“Rebuild”即可生成最终的可运行的jar.</p><p><img src="https://s1.ax1x.com/2020/03/26/Gp1Kkd.png" srcset="/img/loading.gif" alt="Gp1Kkd.png"></p></li></ol><p><img src="https://s1.ax1x.com/2020/03/26/Gp1ojK.png" srcset="/img/loading.gif" alt="Gp1ojK.png"></p><h1 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h1><pre><code class="bash">$ java -jar xxx.jar</code></pre><h1 id="报错没有主清单属性"><a href="#报错没有主清单属性" class="headerlink" title="报错没有主清单属性"></a>报错没有主清单属性</h1><p>因为JAR包中的META-INF文件夹下的MANIFEST.MF文件缺少定义jar接口类,就是缺少默认运行的Main类,步骤3中的路径修改即可。</p><p>也可以手动添加到MANIFEST.MF文件夹</p><p>格式：Main-Class: 包名 类名</p><p>本例：Main-Class: org.springframework.boot.loader.JarLauncher</p><h1 id="编码不一致"><a href="#编码不一致" class="headerlink" title="编码不一致"></a>编码不一致</h1><pre><code>$ java -Dfile.encoding=utf-8 -jar xxx.jar</code></pre><p>-D= # set a system property<br>-D 后面需要跟一个键值对，作用是设置一项系统属性<br>对 -Dfile.encoding=UTF-8 来说就是设置系统属性 file.encoding 为 UTF-8</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无题</title>
    <link href="/2020/wu-ti/"/>
    <url>/2020/wu-ti/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 人类的悲欢并不相通，我只是觉得他们吵闹。──鲁迅</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式版本控制Git</title>
    <link href="/2020/fen-bu-shi-ban-ben-kong-zhi-git/"/>
    <url>/2020/fen-bu-shi-ban-ben-kong-zhi-git/</url>
    
    <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre><code class="bash">$ git init #初始化$ git add . #添加全部到仓库,实际上就是把文件修改添加到暂存区$ git commit -m &quot;message&quot; #提交信息,实际上就是把暂存区的所有内容提交到当前分支$ git status #查看仓库状态$ git diff file #查看文件修改内容$ git log #查看历史记录$ git reset --hard HEAD^ #回退版本$ git reflog #查看回退记录$ git checkout -- file #把文件在工作区的修改全部撤销$ git rm file #删除一个文件</code></pre><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><p>工作区就是你在电脑里能看到的目录，工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><pre><code class="bash">$ git remote add origin URL #添加远程仓库,远程库的名字就是origin$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; #推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;$ git push origin master #将本地的master分支推送到origin主机的master分支。如果后者不存在则会被新建。$ git push origin :master #省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。$ git clone URL #克隆远程到本地$ git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt; #获取并合并分支</code></pre><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><pre><code class="bash">$ git checkout -b dev #创建并切换到分支dev$ git checkout dev #切换到分支dev$ git branch #查看分支$ git merge dev #合并分支到当前$ git branch -d dev #删除分支 -D强制$ git switch -c dev #创建并切换到分支dev,新命令与checkout区分$ git stash #把当前工作现场“储藏”起来，等以后恢复现场后继续工作：$ git stash apply #恢复不删除$ git stash drop #来删除$ git stash pop #恢复的同时把stash内容也删了$ git stash list #查看$ git cherry-pick &lt;commit&gt; #把另外分支提交的修改“复制”到当前分支</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
